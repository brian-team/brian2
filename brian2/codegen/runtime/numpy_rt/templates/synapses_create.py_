# USES_VARIABLES { _synaptic_pre, _synaptic_post,
#                  _pre_synaptic, _post_synaptic, }
# ITERATE_ALL { _idx }
import numpy as np

numpy_False = np.bool_(False)
numpy_True = np.bool_(True)

for i in range(len(_all_pre)):
    j = np.arange(len(_all_post))
    _vectorisation_idx = j

    {% for line in code_lines %}
    {{line}}
    {% endfor %}

    if _cond is False or _cond is numpy_False:
        continue

    if not np.isscalar(_p) or _p != 1:
        _cond_nonzero, = np.logical_and(_cond,
                                       np.random.rand(len(_vectorisation_idx)) < _p).nonzero()
    elif _cond is True or _cond is numpy_True:
        _cond_nonzero = j
    else:
        _cond_nonzero, = _cond.nonzero()

    if not np.isscalar(_n):
        # The "n" expression involved j
        _cond_nonzero = _cond_nonzero.repeat(_n[_cond_nonzero])
    elif _n != 1:
        # We have a j-independent number
        _cond_nonzero = _cond_nonzero.repeat(_n)

    _cur_num_synapses = len(_synaptic_pre_object)
    _numnew = len(_cond_nonzero)
    _new_num_synapses = _cur_num_synapses + _numnew
    _synaptic_pre_object.resize(_new_num_synapses)
    _synaptic_post_object.resize(_new_num_synapses)
    _synaptic_pre_object[_cur_num_synapses:] = _pre_idcs
    _synaptic_post_object[_cur_num_synapses:] = _post_idcs[_cond_nonzero]

    _new_synapses = np.arange(_cur_num_synapses, _new_num_synapses)
    _source_synapses = _pre_synaptic[i]
    _cur_num_source_synapses = len(_source_synapses)
    _source_synapses.resize(_cur_num_source_synapses + _numnew)
    _source_synapses[_cur_num_source_synapses:] = _new_synapses
    for _new_synapse, _target in zip(_new_synapses, _cond_nonzero):
        _target_synapses = _post_synaptic[_target]
        _cur_num_target_synapses = len(_target_synapses)
        _target_synapses.resize(_cur_num_target_synapses + 1)
        _target_synapses[_cur_num_target_synapses] = _new_synapse
