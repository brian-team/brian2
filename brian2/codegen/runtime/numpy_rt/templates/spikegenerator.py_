{% extends 'common_group.py.jinja2' %}

{% block before_code %}
# Copy of the SpikeGeneratorGroup.before_run code
dt = {{dt.item()}}  # Always copy dt
period = {{period_}}  # Always copy period

# Always recalculate timesteps
from brian2 import defaultclock  # Use Brian 2's clock instead of 't'
current_t = defaultclock.t
timesteps = ({{_spike_time}} / dt).astype(np.int32)
current_step = int(current_t / dt)

# Always update _lastindex
in_the_past = np.nonzero(timesteps < current_step)[0]
if len(in_the_past):
    {{_lastindex}}[0] = in_the_past[-1] + 1
else:
    {{_lastindex}}[0] = 0

# Always recalculate _timebins
shift = 1e-3 * dt
timebins = np.asarray(({{_spike_time}} + shift) / dt, dtype=np.int32)

{{_timebins}}[:] = timebins

# Always recalculate period_bins (ignore limit checks)
period_bins = int(round(period / dt))
{{_period_bins}}[0] = period_bins
{% endblock %}

{% block maincode %}
_the_period    = {{_period_bins}}
_timebin       = int(defaultclock.t / {{dt.item()}})  # Use Brian 2's clock instead of 't_in_timesteps'
_n_spikes      = 0

_lastindex_before = {{_lastindex}}

# Always reset _lastindex if period is applied
_timebin %= _the_period
_lastindex_before = 0

_n_spikes = _numpy.searchsorted({{_timebins}}, _timebin, side='right')

{{_lastindex}} = _lastindex_before + _n_spikes
_indices = {{neuron_index}}[_lastindex_before:_lastindex_before+_n_spikes]

{{_spikespace}}[:_n_spikes] = _indices
{{_spikespace}}[-1] = _n_spikes
{% endblock %}
